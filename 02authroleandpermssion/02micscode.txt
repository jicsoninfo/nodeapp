//====================================================================================================
Perfect! Let‚Äôs create a complete Node.js + Express + Mongoose backend that matches the Swagger spec we just built, including:

User registration with email verification

Login with JWT

Two-Factor Authentication (2FA)

Roles and permissions

Fully compatible with Swagger UI

Below is a step-by-step ready-to-run backend.

1Ô∏è‚É£ Project Setup
mkdir auth-system
cd auth-system
npm init -y
npm install express mongoose bcryptjs jsonwebtoken nodemailer speakeasy qrcode dotenv cors body-parser swagger-ui-express


Create folders:

src/
‚îú‚îÄ‚îÄ controllers/
‚îú‚îÄ‚îÄ models/
‚îú‚îÄ‚îÄ routes/
‚îú‚îÄ‚îÄ middleware/
‚îú‚îÄ‚îÄ utils/
‚îî‚îÄ‚îÄ swagger.json


Create .env:

PORT=5050
MONGO_URI=mongodb://localhost:27017/authsystem
JWT_SECRET=your_jwt_secret
EMAIL_USER=your_email@gmail.com
EMAIL_PASS=your_email_password

2Ô∏è‚É£ Models
models/User.js
import mongoose from "mongoose";

const userSchema = new mongoose.Schema({
  name: String,
  email: { type: String, unique: true },
  password: String,
  roles: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Role' }],
  permissions: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Permission' }],
  emailVerified: { type: Boolean, default: false },
  verificationToken: String,
  twoFASecret: String,
  twoFAEnabled: { type: Boolean, default: false }
}, { timestamps: true });

export default mongoose.model("User", userSchema);

models/Role.js
import mongoose from "mongoose";

const roleSchema = new mongoose.Schema({
  name: { type: String, unique: true },
  permissions: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Permission' }]
});

export default mongoose.model("Role", roleSchema);

models/Permission.js
import mongoose from "mongoose";

const permissionSchema = new mongoose.Schema({
  name: { type: String, unique: true }
});

export default mongoose.model("Permission", permissionSchema);

3Ô∏è‚É£ Middleware
middleware/auth.js
import jwt from "jsonwebtoken";
import User from "../models/User.js";

export const auth = async (req, res, next) => {
  const token = req.headers.authorization?.split(" ")[1];
  if (!token) return res.status(401).json({ error: "Unauthorized" });

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = await User.findById(decoded.id);
    if (!req.user) return res.status(401).json({ error: "Unauthorized" });
    next();
  } catch (err) {
    res.status(401).json({ error: "Unauthorized" });
  }
};

4Ô∏è‚É£ Controllers
controllers/authController.js
import User from "../models/User.js";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import crypto from "crypto";
import nodemailer from "nodemailer";
import speakeasy from "speakeasy";
import QRCode from "qrcode";

// Helper to send email
const sendEmail = async (to, subject, html) => {
  const transporter = nodemailer.createTransport({
    service: "gmail",
    auth: { user: process.env.EMAIL_USER, pass: process.env.EMAIL_PASS }
  });
  await transporter.sendMail({ from: process.env.EMAIL_USER, to, subject, html });
};

// Register
export const register = async (req, res) => {
  const { name, email, password } = req.body;
  try {
    const existing = await User.findOne({ email });
    if (existing) return res.status(400).json({ error: "Email already in use" });

    const hashed = await bcrypt.hash(password, 10);
    const verificationToken = crypto.randomBytes(32).toString("hex");

    const user = await User.create({ name, email, password: hashed, verificationToken });

    const verifyLink = `${req.protocol}://${req.get("host")}/api/auth/verify/${verificationToken}`;
    await sendEmail(email, "Verify your email", `<a href="${verifyLink}">${verifyLink}</a>`);

    res.status(201).json({ success: true, message: "Check your email to verify account." });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

// Verify Email
export const verifyEmail = async (req, res) => {
  const { token } = req.params;
  const user = await User.findOne({ verificationToken: token });
  if (!user) return res.status(400).json({ error: "Invalid token" });

  user.emailVerified = true;
  user.verificationToken = null;
  await user.save();
  res.json({ success: true, message: "Email verified successfully!" });
};

// Login
export const login = async (req, res) => {
  const { email, password } = req.body;
  const user = await User.findOne({ email });
  if (!user) return res.status(401).json({ error: "Invalid credentials" });
  if (!user.emailVerified) return res.status(403).json({ error: "Verify email first" });

  const isMatch = await bcrypt.compare(password, user.password);
  if (!isMatch) return res.status(401).json({ error: "Invalid credentials" });

  if (user.twoFAEnabled) return res.json({ twoFARequired: true, userId: user._id });

  const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: "1d" });
  res.json({ token });
};

// Setup 2FA
export const setup2FA = async (req, res) => {
  const secret = speakeasy.generateSecret({ name: "AuthApp" });
  req.user.twoFASecret = secret.base32;
  await req.user.save();

  const qrCodeData = await QRCode.toDataURL(secret.otpauth_url);
  res.json({ qrCode: qrCodeData });
};

// Verify 2FA
export const verify2FA = async (req, res) => {
  const { token } = req.body;
  const verified = speakeasy.totp.verify({ secret: req.user.twoFASecret, encoding: "base32", token });
  if (!verified) return res.status(401).json({ error: "Invalid 2FA code" });

  const jwtToken = jwt.sign({ id: req.user._id }, process.env.JWT_SECRET, { expiresIn: "1d" });
  res.json({ token: jwtToken });
};

5Ô∏è‚É£ Routes
routes/auth.js
import express from "express";
import { register, verifyEmail, login, setup2FA, verify2FA } from "../controllers/authController.js";
import { auth } from "../middleware/auth.js";

const router = express.Router();

router.post("/register", register);
router.get("/verify/:token", verifyEmail);
router.post("/login", login);
router.post("/2fa/setup", auth, setup2FA);
router.post("/2fa/verify", auth, verify2FA);

export default router;

6Ô∏è‚É£ Main App ‚Äî server.js
import express from "express";
import mongoose from "mongoose";
import dotenv from "dotenv";
import cors from "cors";
import bodyParser from "body-parser";
import swaggerUi from "swagger-ui-express";
import authRoutes from "./routes/auth.js";
import fs from "fs";

dotenv.config();

const app = express();
app.use(cors());
app.use(bodyParser.json());

mongoose.connect(process.env.MONGO_URI).then(() => console.log("MongoDB connected"));

app.use("/api/auth", authRoutes);

// Swagger
const swaggerDocument = JSON.parse(fs.readFileSync("./src/swagger.json"));
app.use("/swagger", swaggerUi.serve, swaggerUi.setup(swaggerDocument));

app.listen(process.env.PORT || 5050, () => console.log(`Server running on port ${process.env.PORT}`));


‚úÖ This gives you:

User registration with email verification

Login (blocks unverified users)

Two-Factor Authentication (TOTP/QR code)

Swagger UI at /swagger

JWT-based auth

If you want, I can also add full Role & Permission management in this backend next, so your admin can create roles, assign permissions, and protect routes just like Spatie in Laravel.

Do you want me to do that?
//====================================================================================================
To build Node.js + Express + Mongoose Authentication with Roles/Permissions, you typically install these packages:

‚úÖ Core Packages
1. Express (Server Framework)
npm install express

2. Mongoose (MongoDB ORM)
npm install mongoose

‚úÖ Authentication Packages
3. bcrypt (Password hashing)
npm install bcrypt

4. jsonwebtoken (JWT authentication)
npm install jsonwebtoken

Optional (instead of bcrypt)

bcryptjs ‚Üí pure JS version

npm install bcryptjs

‚úÖ Roles & Permissions Packages

You can implement roles manually OR use a package:

Option A ‚Äî Implement Roles Manually (Recommended)

No extra package needed‚Äîstore roles in MongoDB and check in middleware.

Option B ‚Äî Use RBAC Package
‚≠ê Best choice: accesscontrol
npm install accesscontrol

Others:

rbac

npm install rbac


node-rbac

npm install node-rbac


But AccessControl is most common.

‚úÖ Express Middleware Packages
5. dotenv ‚Äî load environment variables
npm install dotenv

6. cookie-parser (if using cookies)
npm install cookie-parser

7. cors (for API security)
npm install cors

Optional but Recommended
8. express-rate-limit (security against brute-force)
npm install express-rate-limit

9. helmet (API security headers)
npm install helmet

üì¶ Final Recommended Install Command

If you want everything:

npm install express mongoose bcrypt jsonwebtoken accesscontrol dotenv cors cookie-parser helmet express-rate-limit


If you'd like, I can also generate:
‚úÖ Folder structure
‚úÖ Auth middleware (JWT)
‚úÖ Role-based authorization middleware
‚úÖ User model with roles
‚úÖ Controller examples
Just tell me!
//====================================================================================================
Great question ‚Äî and very important for multi-environment setups.
‚úÖ You can define NODE_ENV in two places:

Option 1: Define NODE_ENV in .env file (YES, you can)
Example .env.development:
NODE_ENV=development
PORT=5000
DB_URL=mongodb://localhost:27017/mydb

Then in your code:
dotenv.config({ path: `.env.${process.env.NODE_ENV}` });

BUT ‚Üí this works only if NODE_ENV is already set BEFORE loading
(so this pattern usually doesn‚Äôt work by itself).
Because you need NODE_ENV to determine which file to load.
Therefore: This option is NOT recommended for selecting env files.

Option 2: Set NODE_ENV at runtime (BEST PRACTICE)
Linux / macOS
NODE_ENV=development node src/server.js

Windows CMD
set NODE_ENV=development && node src/server.js

Windows PowerShell
$env:NODE_ENV="development"; node src/server.js

This is the industry-standard way used in:


production servers


Docker


CI/CD pipelines


PM2 process manager



Option 3: Use npm scripts (recommended for local dev)
package.json:
"scripts": {
  "dev": "NODE_ENV=development node src/server.js",
  "prod": "NODE_ENV=production node src/server.js"
}

For Windows compatibility:
"scripts": {
  "dev": "cross-env NODE_ENV=development node src/server.js",
  "prod": "cross-env NODE_ENV=production node src/server.js"
}

Install:
npm install cross-env --save-dev


Summary: Where should you define NODE_ENV?
WhereWorks?Recommended?In .env file‚ö†Ô∏è Only after dotenv loads‚ùå No (can't control which env file loads)As runtime variable (NODE_ENV=dev)‚úîÔ∏è Yes‚≠ê Best for backendIn npm scripts‚úîÔ∏è Yes‚≠ê Best for local devIn hosting provider dashboard‚úîÔ∏è Yes‚≠ê Best for production

‚≠ê Best Practice Answer
Do NOT store NODE_ENV in .env
You should set NODE_ENV using npm scripts or runtime environment, not inside the .env file.

If you want, I can create a full working multi-environment folder structure for your project.
//====================================================================================================
You do NOT need to define the full absolute path unless your .env files are located in a different folder.

By default, dotenv loads files relative to the folder where you run the Node process (usually the project root).

‚úÖ Where .env files should be?

Typically:

project/
 ‚îú‚îÄ‚îÄ src/
 ‚îú‚îÄ‚îÄ node_modules/
 ‚îú‚îÄ‚îÄ package.json
 ‚îú‚îÄ‚îÄ .env
 ‚îú‚îÄ‚îÄ .env.development
 ‚îú‚îÄ‚îÄ .env.production
 ‚îî‚îÄ‚îÄ .env.test


If your files are in the project root, then this is enough:

dotenv.config({ path: `.env.${process.env.NODE_ENV}` });


Node will look in the same directory where you start your app.

üîç When do you need full path?

Only if your .env files are NOT in the project root.

Example:

project/
  config/env/.env.development
  config/env/.env.production
  src/server.js


Then you must use:

dotenv.config({ path: './config/env/.env.development' });


or dynamically:

dotenv.config({ path: `./config/env/.env.${process.env.NODE_ENV}` });

üéØ Final Answer
‚ùå Full path NOT required

If .env.* files are in the root folder.

‚úîÔ∏è Full path required

Only if the .env files are in a different folder.

‚≠ê Example: Best practice setup
server.js
import dotenv from 'dotenv';

dotenv.config(); // loads .env
dotenv.config({ path: `.env.${process.env.NODE_ENV}` }); // loads environment-specific

console.log("Environment:", process.env.NODE_ENV);
console.log("Port:", process.env.PORT);

Run:

Development:

NODE_ENV=development node src/server.js


Production:

NODE_ENV=production node src/server.js


If you want, I can help you organize your .env files for a real-world project setup.

Ah ‚Äî you‚Äôre asking:

üëâ ‚ÄúDoes Node.js upload all .env files automatically, or only when we call dotenv.config()?‚Äù
üëâ ‚ÄúWill multiple .env files load automatically or only when we specify them?‚Äù

Let me explain clearly:

‚úÖ dotenv does NOT upload or load all .env files automatically

dotenv only loads the env file(s) you explicitly tell it to load.

‚úîÔ∏è This loads ONLY .env
dotenv.config();

‚úîÔ∏è This loads ONLY .env.development
dotenv.config({ path: '.env.development' });

‚úîÔ∏è This loads both files (manual loading)
dotenv.config(); // loads .env
dotenv.config({ path: `.env.${process.env.NODE_ENV}` }); // loads env based on environment

‚ùå dotenv does NOT automatically load all .env.* files

You must load each file manually.

üéØ So the answer:
‚ùå .env files are NOT uploaded automatically
‚ùå dotenv does NOT load all env files
‚úîÔ∏è dotenv loads ONLY the file(s) you call with dotenv.config()
‚úîÔ∏è If you want multiple .env files loaded, you must call dotenv multiple times
üìå Example: Only environment-specific file will load
dotenv.config({ path: `.env.${process.env.NODE_ENV}` });


If NODE_ENV=development ‚Üí only .env.development is loaded.

If NODE_ENV=production ‚Üí only .env.production is loaded.

.env will NOT be loaded unless you also call:

dotenv.config(); // loads .env first

‚≠ê Real-world recommended setup
Load default .env and override with environment-specific:
dotenv.config();  // loads .env
dotenv.config({ path: `.env.${process.env.NODE_ENV}` }); // overrides

‚ö†Ô∏è Important

dotenv does not upload anywhere ‚Äî it simply:

‚úîÔ∏è Reads the .env file
‚úîÔ∏è Injects the variables into process.env
‚úîÔ∏è That‚Äôs all

It never sends data to external servers.

üü¢ Summary
Question	Answer
Does dotenv upload all env files?	‚ùå No
Does dotenv load all env files?	‚ùå No
Does dotenv load only the one we specify?	‚úÖ Yes
Can dotenv load multiple files?	‚úÖ Yes, but only if you call config() multiple times

If you want, I can also show you a perfect production-ready .env loading system.

//====================================================================================================
Great ‚Äî here is a clean, professional, production-ready Node.js project structure with:

‚úî Multiple server files
‚úî Multiple .env files
‚úî Separate configs for development, production, and testing
‚úî npm scripts to run each environment
‚úî dotenv multi-environment setup

‚≠ê Project Structure
project/
‚îÇ
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ server.js           ‚Üê main production server
‚îÇ   ‚îú‚îÄ‚îÄ server.dev.js       ‚Üê development server
‚îÇ   ‚îú‚îÄ‚îÄ server.test.js      ‚Üê test server
‚îÇ   ‚îú‚îÄ‚îÄ app.js              ‚Üê express app (shared by all servers)
‚îÇ   ‚îî‚îÄ‚îÄ config/
‚îÇ         ‚îî‚îÄ‚îÄ loadEnv.js    ‚Üê environment loader
‚îÇ
‚îú‚îÄ‚îÄ .env                    ‚Üê default env
‚îú‚îÄ‚îÄ .env.development        ‚Üê development env
‚îú‚îÄ‚îÄ .env.production         ‚Üê production env
‚îú‚îÄ‚îÄ .env.test               ‚Üê test env
‚îÇ
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ .gitignore

‚≠ê 1. Shared Express App (src/app.js)
import express from 'express';

const app = express();

app.get('/', (req, res) => {
  res.send(`Server running in ${process.env.NODE_ENV} mode`);
});

export default app;

‚≠ê 2. Environment Loader (src/config/loadEnv.js)
import dotenv from 'dotenv';

// Load default .env
dotenv.config();

// Load environment-specific file: .env.development, .env.production, etc.
if (process.env.NODE_ENV) {
  dotenv.config({ path: `.env.${process.env.NODE_ENV}` });
}

console.log(`Environment Loaded: ${process.env.NODE_ENV}`);

‚≠ê 3. Production Server (src/server.js)
import './config/loadEnv.js';
import app from './app.js';

const PORT = process.env.PORT || 8000;

app.listen(PORT, () => {
  console.log(`üöÄ Production server running on port ${PORT}`);
});

‚≠ê 4. Development Server (src/server.dev.js)
import './config/loadEnv.js';
import app from './app.js';

const PORT = process.env.PORT || 5001;

app.listen(PORT, () => {
  console.log(`üöÄ Development server running on port ${PORT}`);
});

‚≠ê 5. Test Server (src/server.test.js)
import './config/loadEnv.js';
import app from './app.js';

const PORT = process.env.PORT || 5002;

app.listen(PORT, () => {
  console.log(`üöÄ Test server running on port ${PORT}`);
});

‚≠ê 6. Environment Files
.env (default)
APP_NAME=MyApp
COMMON_VAR=commonValue

.env.development
NODE_ENV=development
PORT=5001
DB_URL=mongodb://localhost:27017/devdb

.env.production
NODE_ENV=production
PORT=8000
DB_URL=mongodb://live-server-url/proddb

.env.test
NODE_ENV=test
PORT=5002
DB_URL=mongodb://localhost:27017/testdb

‚≠ê 7. package.json Scripts
{
  "name": "multi-env-server",
  "type": "module",
  "scripts": {
    "start": "NODE_ENV=production node src/server.js",
    "dev": "NODE_ENV=development node src/server.dev.js",
    "test-server": "NODE_ENV=test node src/server.test.js"
  },
  "dependencies": {
    "dotenv": "^17.2.3",
    "express": "^5.1.0"
  }
}


On Windows, use cross-env:

npm install cross-env --save-dev

"scripts": {
  "start": "cross-env NODE_ENV=production node src/server.js",
  "dev": "cross-env NODE_ENV=development node src/server.dev.js",
  "test-server": "cross-env NODE_ENV=test node src/server.test.js"
}

‚≠ê 8. .gitignore
.env
.env.*
node_modules

‚≠ê 9. Run Each Server
Production:
npm start

Development:
npm run dev

Test:
npm run test-server

üéâ This structure is professional and scalable

It separates:

‚úî App logic
‚úî Environment configuration
‚úî Different server entry points
‚úî Multiple .env files
‚úî Production & development behavior

If you want, I can now generate:

üîπ Folder templates
üîπ Sample API routes
üîπ Mongoose database connection
üîπ Auth middleware

Just tell me!
//====================================================================================================
You're seeing this behavior:

‚úîÔ∏è Server starts immediately
‚ùå MongoDB connection error appears after a delay

This happens because your server starts listening BEFORE MongoDB finishes connecting.

Let me explain and show you the fix.

‚ùó Why the problem happens

Your code order:

dotenv.config();
connectDB();          // async but NOT awaited
const app = express();
app.listen(process.env.PORT, () => console.log("server is running"));


connectDB() is async, but you‚Äôre not using await, so Node does NOT wait for MongoDB.

So the flow is:

connectDB() starts connecting in background

Server immediately starts (app.listen)

After 1‚Äì3 seconds ‚Üí MongoDB connection fails ‚Üí error appears

This is expected behavior.

‚úÖ Solution: WAIT for MongoDB before starting server

You must wrap server startup inside an async function and await connectDB().

‚≠ê Corrected server.js (best practice)
import express from 'express';
import dotenv from 'dotenv';
import { connectDB } from './config/db.js';

dotenv.config();

const app = express();

// Start server AFTER DB connects
const startServer = async () => {
  try {
    await connectDB();  // wait for MongoDB connection
    app.listen(process.env.PORT, () =>
      console.log(`server is running on port ${process.env.PORT}`)
    );
  } catch (err) {
    console.error("Failed to start server:", err.message);
    process.exit(1);
  }
};

startServer();

‚≠ê Your db.js stays same
import mongoose from 'mongoose';

export const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log('MongoDB Connected');
  } catch (err) {
    console.error(err.message);
    process.exit();
  }
};

‚úîÔ∏è What happens now
Sequence AFTER FIX:

.env loads

MongoDB tries to connect

IF connection is successful ‚Üí server starts

IF connection fails ‚Üí server does NOT start

This is how professional Node.js apps behave.

‚ùó If MongoDB connection is slow or wrong URI

Your server will not start, and you will instantly see:

Failed to start server: <mongo error>


This avoids:

random crashes

delayed errors

half-working API

‚≠ê If you want, I can also add:

‚úî Retry logic for DB
‚úî Logging
‚úî Shutdown handling
‚úî Mongoose options
‚úî Health check route
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================
//====================================================================================================